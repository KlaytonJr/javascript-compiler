/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */

options
{
  static = false;
}

PARSER_BEGIN(javascript)

import java.io.File;
import java.util.Scanner;

public class javascript
{
  public static void main(String args []) throws ParseException
  {
    try {
        File file = new File("./ex.txt");
        Scanner sc = new Scanner(file);
        String line = "";

        Boolean opened = false;

        while (sc.hasNextLine()) {
            try {
                String actual_line = sc.nextLine();
                System.out.println(actual_line);
                if (actual_line.endsWith("{") || opened) {
                    opened = true;
                    line += actual_line;
                    if (actual_line.startsWith("}") && !actual_line.endsWith("{")) {
                        opened = false;
                        System.out.println(line);
                        new javascript(new java.io.StringReader(line)).INICIO();
                        line = "";
                    }
                } else {
                    new javascript(new java.io.StringReader(actual_line)).INICIO();
                }
            } catch(Throwable e) {
                throw e;
            }
        }
        System.out.println("\nA Sintaxe Correta. Tokens Identificados.\n");
	}catch(Throwable e) {
		System.out.println("\n\nErro na sintaxe: " + e.getMessage());
	}
  }
}

PARSER_END(javascript)

SKIP:
{ " " | "\r" | "\t" | "\n" }


/* ========================================================================== */
/* Characteres Padrão */
/* ========================================================================== */

TOKEN:
{
        < #DIGITO: ["0" - "9"] >
    |   < #LETRA : (["a" - "z"] | ["A" - "Z"]) >
    |   < ASPAS: "\"" | "\'" | "`" >
    |   < NEGACAO: "!" >
    |   < INCREMENTO: "++" >
    |   < DECREMENTO: "--" >
}


/* ========================================================================== */
/* Palavras Reservadas */
/* ========================================================================== */

TOKEN:
{
        < RETURN: "return" > : DEFAULT
    |   < IF: "if" > : DEFAULT
    |   < ELSE_IF: "else if" > : DEFAULT
    |   < ELSE: "else" > : DEFAULT
    |   < WHILE: "while" > : DEFAULT
    |   < PRINT: "console.log" > : DEFAULT
    |   < PROMPT: "prompt" > : DEFAULT
    |   < NULL: "null" > : DEFAULT
    |   < TRUE: "true" > : DEFAULT
    |   < FALSE: "false" > : DEFAULT
    |   < NEW: "new" > : DEFAULT
    |   < FUNCTION: "function" > : DEFAULT
    |   < FUNCTION_UPPER: "Function" > : DEFAULT
    |   < TYPE: "let" | "var" | "const" > : DEFAULT
}


/* ========================================================================== */
/* Tipos Básicos - Inteiro, Real, String + Identificador */
/* ========================================================================== */

TOKEN:
{                                                                      
        < INTEIRO:(("+" | "-")? (<DIGITO>)+ (".")? ("0")*) | (("+" | "-")? (".") ("0")+ )> 
    |   < REAL: ("+" | "-")? (<DIGITO>)* (".") (<DIGITO>)+ ( ("E" | "e" ) ( "+" | "-" )? (<DIGITO>)+ )? >

}

// TO DO: Add caracteres especiais
TOKEN:{
    < STRING: <ASPAS> (<LETRA> | <DIGITO> | " ")* <ASPAS> >
}

TOKEN:
{
    < IDENTIFICADOR : (<LETRA>| "$" | "_" ) (<LETRA> | <DIGITO>| "$" | "_ ")* >
}

void INICIO():
{}
{
   linha() 
}

void linha():
{}
{
    (
        expressao() (";")? 
    |   comandoEntrada() (";")? 
    |   comandoSaida() (";")? 
    |   condicionalSe() 
    |   lacoWhile() (";")? 
    |   declaracaoDeFuncao())* (";")? 
}


/* ========================================================================== */
/* Expressão */
/* ========================================================================== */

void expressao():
{}
{
    [<NEGACAO>] ( 
        (
               (<TYPE> | (<INCREMENTO> | <DECREMENTO>))? <IDENTIFICADOR> (ChamadaDeMetodo() | <INCREMENTO> | <DECREMENTO>)?
            |   ExpressaoLiteral()
            |   "(" (expressao())? ("," expressao())* ")" ("=>" escopoFuncao())?
        ) (Atribuicao() | ComparacaoLogica() | ComparacaoRelacional() | expressaoNumerica())? 
    )
}

void ExpressaoLiteral():
{}
{
    <INTEIRO> | <REAL> | <STRING> | <TRUE> | <FALSE>
}


/* ========================================================================== */
/* Operações */
/* ========================================================================== */

void Atribuicao():
{}
{
  "=" (expressao() | declaracaoDeFuncao())
}

void ComparacaoLogica():
{}
{
  ("&&" | "||") expressao()
}

void ComparacaoRelacional():
{}
{
  (">" | "<" | ">=" | "<=" | "==" | "!=" | "!==" | "===") expressao()
}

void expressaoNumerica():
{}
{
  ("+" | "+=" | "-" | "-=" | "*" | "**" | "**=" | "*=" | "/" | "/=" | "%" | "%=" | "|=" | "^=" | "&=") expressao()
}


/* ========================================================================== */
/* Comando de Entrada e Saída */
/* ========================================================================== */

void comandoEntrada():
{}
{
    <PROMPT> ("(") <STRING> (")")
}

void comandoSaida():
{}
{
    <PRINT> ("(") ListaDeArgumentos() (")")
}


/* ========================================================================== */
/* Se, Senão Se, Senão */
/* ========================================================================== */

void condicionalSe():
{}
{
    <IF> "(" expressao() ")" escopoFuncao() (condicionalSenaoSe() | condicionalSenao())?
}

void condicionalSenaoSe():
{}
{
    <ELSE_IF> "(" expressao() ")" escopoFuncao() (condicionalSenaoSe() | condicionalSenao())?
}

void condicionalSenao():
{}
{
    <ELSE> escopoFuncao()
}


/* ========================================================================== */
/* Laço while */
/* ========================================================================== */

void lacoWhile():
{}
{
    <WHILE> "(" expressao() ")" escopoFuncao()
}


/* ========================================================================== */
/* Declaração e Chamada de Função */
/* ========================================================================== */

void declaracaoDeFuncao():
{}
{
      <FUNCTION> (<IDENTIFICADOR>)? ChamadaDeMetodo() escopoFuncao()
    | (<NEW> <FUNCTION_UPPER> | <FUNCTION_UPPER>) ChamadaDeMetodo() ("=>" escopoFuncao())?
    | "(" declaracaoDeFuncao() ")"
}

void escopoFuncao():
{}
{
  "{" linha() (<RETURN> (expressao() | declaracaoDeFuncao()))? "}"
}

void ChamadaDeMetodo():
{}
{
  "(" (ListaDeArgumentos())? ")"
}

void ListaDeArgumentos():
{}
{
  expressao() ("," expressao())*
}